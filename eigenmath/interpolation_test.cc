// Copyright 2023 Google LLC

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "interpolation.h"

#include <random>

#include "distribution.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "matchers.h"
#include "sampling.h"
#include "so3.h"
#include "types.h"

namespace eigenmath {
namespace {

using ::testing::DoubleEq;
using testing::IsApprox;

TEST(PercentageTest, Samples) {
  EXPECT_THAT(Percentage(0.5, 0.0, 1.0), DoubleEq(0.5));
  EXPECT_THAT(Percentage(5, 0, 10), DoubleEq(0.5));
  EXPECT_THAT(Percentage(0.1, 0.0, 10.0), DoubleEq(0.01));
  EXPECT_THAT(Percentage(0.1, 0.1, 0.0), DoubleEq(0.0));
  EXPECT_THAT(Percentage(0.1, 0.1, 1.0), DoubleEq(0.0));
}

TEST(InterpolateLinearTest, Samples) {
  // See accompanying Mathematica notebook test_interpolation.nb for generating
  // test data.
  const double tolerance = 1e-5;
  double data[20][4] = {{0.994113, 5.40177, 9.87456, 9.84823},
                        {0.754223, 2.66633, 8.85648, 7.33509},
                        {0.457579, 9.17846, -9.53226, 0.616827},
                        {0.211632, 4.15704, 4.83046, 4.29956},
                        {0.739719, 4.22623, 6.39299, 5.82902},
                        {0.146888, 0.92004, 3.63072, 1.31821},
                        {0.300672, -4.38491, -5.30372, -4.66117},
                        {0.0603481, -4.16586, 4.81159, -3.62408},
                        {0.568616, -3.85352, -5.36646, -4.7138},
                        {0.827705, -0.346784, -6.25296, -5.23536},
                        {0.195272, -4.72502, -1.51241, -4.09769},
                        {0.472596, -6.91928, 6.60286, -0.528772},
                        {0.876267, -3.02747, -1.03005, -1.2772},
                        {0.139066, -8.0908, -8.94064, -8.20898},
                        {0.246991, -1.3001, 7.9686, 0.98918},
                        {0.0362462, -5.05807, -9.60207, -5.22277},
                        {0.299644, -5.48942, -3.44976, -4.87825},
                        {0.544016, -4.20966, -8.48297, -6.53441},
                        {0.945902, -0.521225, 0.319534, 0.27405},
                        {0.599646, 8.56478, 2.19591, 4.74572}};
  for (const auto& sample : data) {
    double actual = InterpolateLinear(sample[0], sample[1], sample[2]);
    EXPECT_NEAR(sample[3], actual, tolerance);
  }
}

TEST(InterpolateLinearInBoxTest, AtZero) {
  const Vector3d min{-1, 0, 10};
  const Vector3d max{1, 1, 100};

  const Vector3d zero = Vector3d::Zero();
  EXPECT_THAT(InterpolateLinearInBox(zero, min, max), min);
}

TEST(InterpolateLinearInBoxTest, AtOnes) {
  const Vector3d min{-1, 0, 10};
  const Vector3d max{1, 1, 100};

  const Vector3d one = Vector3d::Ones();
  EXPECT_THAT(InterpolateLinearInBox(one, min, max), max);
}

TEST(InterpolateLinearInBoxTest, AtIntermediateValue) {
  const Vector3d min{-1, 0, 10};
  const Vector3d max{1, 1, 100};

  const Vector3d param{0.2, 0.6, 0.4};
  const Vector3d result{-0.6, 0.6, 46};
  EXPECT_THAT(InterpolateLinearInBox(param, min, max), IsApprox(result));
}

TEST(InterpolateQuadraticTest, Samples) {
  // See accompanying Mathematica notebook test_interpolation.nb for
  // generating test data.
  const double tolerance = 1e-4;
  double data[20][5] = {{0.150197, -9.44357, -6.8933, 3.77222, -9.57844},
                        {0.993741, -1.21116, 9.27437, -0.0382932, 9.27031},
                        {0.0243865, 6.54826, -5.79428, -6.42744, 6.10798},
                        {0.110881, 5.4475, -8.97065, 7.43913, 2.32918},
                        {0.362327, 4.11192, 7.86858, -0.224024, 6.84192},
                        {0.129015, -0.256395, 5.18793, 4.03509, 0.81667},
                        {0.423879, -8.41936, -7.93517, 1.59279, -9.31839},
                        {0.426778, 7.35217, -8.91411, 8.13636, -3.66519},
                        {0.285512, -9.43404, -4.53308, -4.94992, -7.49235},
                        {0.270145, -8.24509, -7.24494, -4.99791, -8.09783},
                        {0.914561, -6.9089, -2.459, -1.68402, -2.69562},
                        {0.67214, -3.91998, -3.91556, -1.97573, -4.13026},
                        {0.500046, 6.08209, -8.04807, 2.8988, -4.11827},
                        {0.491439, 8.56763, -5.08374, 5.71349, -1.19637},
                        {0.545653, -5.28392, -8.58153, -8.27182, -7.53043},
                        {0.529925, -4.12714, -7.71658, -5.9131, -6.70097},
                        {0.460343, 8.23116, -6.58359, -6.239, -0.471706},
                        {0.220145, 2.04898, 8.91735, 0.561936, 4.86784},
                        {0.92478, -3.28417, 8.50983, 7.25171, 8.07665},
                        {0.732042, -8.50648, -3.91525, -8.68991, -4.22692}};
  for (const auto& sample : data) {
    double actual =
        InterpolateQuadratic(sample[0], sample[1], sample[2], sample[3]);
    EXPECT_NEAR(sample[4], actual, tolerance);
  }
}

TEST(InterpolateQuadraticTest, ScaledSamples) {
  // See accompanying Mathematica notebook test_interpolation.nb for
  // generating test data.
  const double tolerance = 6e-4;
  double data[20][8] = {
      {0.508563, -7.27076, -1.66292, 7.59186, 9.22588, -0.187426, -1.3763,
       -2.07061},
      {0.741342, -5.03522, -7.5681, -2.85757, -2.47251, -2.2428, -4.86911,
       -13.2867},
      {0.115259, -3.99918, -8.58549, -0.645784, -7.1201, -6.86738, -6.06219,
       -5.67595},
      {0.449941, 0.324071, 4.36356, 0.542096, 0.944805, -0.607424, -4.09141,
       -2.03166},
      {0.179822, -3.08529, -0.35767, 5.25011, 5.74299, 0.486352, 0.942857,
       -0.126597},
      {0.81566, -4.17462, 0.78792, 3.17313, -7.103, 8.01112, 3.15346, 7.99986},
      {0.109598, 0.498322, -9.11711, -9.72945, 3.98159, -0.195077, -6.43027,
       7.23125},
      {0.661516, 0.813976, -2.77172, 0.588008, 9.85282, -4.69619, -5.40159,
       -0.650913},
      {0.351813, 0.937561, 2.71549, -7.3186, 7.20517, 4.30098, -7.15673,
       7.69655},
      {0.863169, -4.66867, -2.45817, -6.29173, 6.02376, -5.75623, -5.83977,
       -84.0286},
      {0.515595, -5.93021, 7.6437, 8.09235, -0.761565, 3.62432, -4.18991,
       59.4497},
      {0.967672, -0.217064, 5.52829, 0.158358, -9.95409, -3.03614, -3.9201,
       6.43284},
      {0.735451, -4.19197, -1.19406, -0.478297, -0.47739, 9.50811, -4.75283,
       -43.6008},
      {0.317833, -2.04279, -8.98526, 5.54615, 1.97251, -6.65556, -0.345531,
       2.56644},
      {0.502439, -5.44993, 3.27348, 9.63654, 9.6017, 1.99122, 9.71211, 2.12828},
      {0.835295, -6.00124, 2.56432, -8.66898, -5.71459, -2.67733, 2.36491,
       -6.85048},
      {0.727187, -4.25658, 8.43202, 3.07816, 4.29088, 2.91401, -6.58288,
       -6.10447},
      {0.362326, -5.01468, -0.209738, -6.76198, -8.63856, 7.47392, 1.41235,
       13.6669},
      {0.00360386, 7.68188, 1.32055, -3.11676, -6.34467, -8.38591, -7.11944,
       -8.24076},
      {0.438349, -9.19133, 2.0257, -1.06963, 2.6265, 9.73736, -9.89738,
       -2.01446}};
  for (const auto& sample : data) {
    double actual =
        InterpolateQuadratic(sample[0], sample[1], sample[2], sample[3],
                             sample[4], sample[5], sample[6]);
    EXPECT_NEAR(sample[7], actual, tolerance);
  }
}

TEST(CubicHermiteSplineCoefficients, Samples) {
  // See accompanying Mathematica notebook test_interpolation.nb for
  // generating test data.
  const double tolerance = 1e-5;
  double data[20][5] = {
      {0.19848, 0.897455, 0.12751, 0.102545, -0.0315752},
      {0.261265, 0.830889, 0.14258, 0.169111, -0.0504257},
      {0.431217, 0.602524, 0.139505, 0.397476, -0.105764},
      {0.433175, 0.59964, 0.139175, 0.40036, -0.106359},
      {0.201159, 0.894885, 0.128369, 0.105115, -0.0323251},
      {0.86927, 0.0468029, 0.0148562, 0.953197, -0.0987838},
      {0.943721, 0.00914538, 0.00298904, 0.990855, -0.0501224},
      {0.364747, 0.697931, 0.147192, 0.302069, -0.0845144},
      {0.476808, 0.534763, 0.130517, 0.465237, -0.118946},
      {0.156006, 0.93458, 0.111127, 0.0654198, -0.020541},
      {0.627833, 0.312428, 0.08696, 0.687572, -0.146699},
      {0.772719, 0.131489, 0.0399161, 0.868511, -0.135708},
      {0.675509, 0.247549, 0.0711272, 0.752451, -0.148069},
      {0.902143, 0.0268539, 0.00863893, 0.973146, -0.0796422},
      {0.540293, 0.439691, 0.11418, 0.560309, -0.134196},
      {0.8023, 0.101802, 0.0313582, 0.898198, -0.127257},
      {0.475869, 0.536168, 0.130727, 0.463832, -0.11869},
      {0.654811, 0.275203, 0.0780242, 0.724797, -0.148009},
      {0.459032, 0.561314, 0.134334, 0.438686, -0.113988},
      {0.803677, 0.100495, 0.030976, 0.899505, -0.126804}};
  for (const auto& sample : data) {
    double a, b, c, d;
    CubicHermiteSplineCoefficients(sample[0], a, b, c, d);
    EXPECT_NEAR(sample[1], a, tolerance);
    EXPECT_NEAR(sample[2], b, tolerance);
    EXPECT_NEAR(sample[3], c, tolerance);
    EXPECT_NEAR(sample[4], d, tolerance);
  }
}

TEST(InterpolateCubicHermite, Samples) {
  // See accompanying Mathematica notebook test_interpolation.nb for
  // generating test data.
  const double tolerance = 1e-5;
  double data[20][6] = {
      {0.700676, 9.83659, 1.11465, -0.976597, 7.60395, 0.302405},
      {0.144217, -9.81331, 1.81537, -2.06312, -0.341854, -9.1784},
      {0.889014, 4.1694, -8.80767, -1.4549, -3.60664, -1.04253},
      {0.535627, -4.95413, -9.1941, -7.21682, 7.6204, -8.28339},
      {0.966177, -3.78143, 9.22848, -5.54735, -3.83671, -5.41009},
      {0.143023, -0.0284819, 9.54825, -5.41501, -5.43861, 0.770745},
      {0.168504, 8.81321, -7.22473, -1.6278, -9.62486, 7.40929},
      {0.989756, -8.13398, -6.14903, -8.48349, -8.02677, -8.40347},
      {0.948841, -6.5336, -9.75375, 2.19291, 7.28871, 1.76681},
      {0.811534, 9.87289, -3.5138, 3.13441, 7.94035, 2.67538},
      {0.416496, 8.73286, -1.4769, 2.95125, 3.78309, 5.96714},
      {0.764675, -9.12276, 0.429236, -0.652507, 3.19958, -2.26103},
      {0.593928, 8.23758, 1.81791, 1.4804, 6.45097, 3.17215},
      {0.714926, -7.71832, 2.72217, -5.1758, -2.58048, -5.14371},
      {0.422764, -9.34828, 7.76687, -8.54122, 2.1577, -8.16603},
      {0.502125, -5.40826, 3.28402, -4.93854, 4.02507, -5.26841},
      {0.9549, -4.1741, -4.72994, 5.75747, -5.91514, 5.93276},
      {0.92821, 2.11167, 4.9328, 4.37928, -0.0957299, 4.37542},
      {0.67829, 2.79838, -2.20523, -9.42025, 2.62913, -6.98408},
      {0.328413, -6.74838, -0.101914, -9.89323, -5.71887, -7.14401}};
  for (const auto& sample : data) {
    double actual = InterpolateCubicHermite(sample[0], sample[1], sample[2],
                                            sample[3], sample[4]);
    EXPECT_NEAR(sample[5], actual, tolerance);
  }
}

TEST(InterpolateCubicHermiteTest, ScaledSamples) {
  // See accompanying Mathematica notebook test_interpolation.nb for
  // generating test data.
  const double tolerance = 5e-3;
  double data[20][10] = {{8.01987, 6.25643, 6.58775, 7.56759, 8.40683, -1.31979,
                          0.477782, -2.10124, -0.0579821, 0.385407},
                         {-3.90714, -4.06668, -3.9849, -3.91762, -3.10611,
                          1.36491, -0.965584, -0.619206, 2.30137, -0.607845},
                         {3.18215, 2.43126, 2.81279, 3.59426, 3.98273, 0.983208,
                          -0.137668, 1.3588, -1.90552, 0.795354},
                         {-5.47159, -6.01891, -5.84446, -5.20773, -4.8802,
                          2.26903, -0.424701, -0.823302, -0.0172956, -1.2721},
                         {-6.51424, -6.97331, -6.63572, -6.5049, -5.61415,
                          1.66018, -2.92752, -0.300937, -2.68046, -0.407201},
                         {-0.586891, -0.636447, 0.228747, 1.16664, 1.41537,
                          -2.4754, 1.11421, 0.381707, -2.29532, 1.34198},
                         {0.697155, -0.297669, 0.111217, 0.858846, 1.0794,
                          -2.76957, -2.99315, 2.38599, 1.64289, 1.64114},
                         {-6.69005, -8.1941, -7.5765, -6.84836, -6.61798,
                          2.78144, -2.52428, 0.17717, 0.799974, 0.388692},
                         {4.60768, 4.48777, 4.83392, 5.47735, 6.21237, 1.21941,
                          1.19188, 0.848942, -1.98535, 1.39741},
                         {3.30444, 1.55156, 2.41357, 2.93473, 3.58895,
                          -0.0477793, -1.18556, 2.11348, -2.74233, -4.68976},
                         {-4.19322, -4.42916, -4.27867, -4.22146, -4.0836,
                          -0.776809, 2.1676, -0.186378, 1.83128, 1.04076},
                         {-6.93949, -8.94372, -8.1597, -7.41826, -6.46438,
                          -1.09623, -0.461692, -0.812385, -1.69904, -1.00862},
                         {10.1581, 9.75083, 10.1371, 10.5981, 10.6003, 2.69146,
                          2.12907, 1.61138, -1.3102, 2.70405},
                         {1.52945, 0.436584, 0.573146, 1.44778, 2.40069, -0.751,
                          -1.73969, 0.900177, -1.93645, 0.811261},
                         {8.18492, 7.90946, 8.86288, 9.47393, 10.0818, 1.68411,
                          -2.71443, -2.44927, 0.49041, 1.11274},
                         {-3.53723, -3.77589, -3.1202, -2.1409, -1.20643,
                          1.76901, 2.67375, -1.68513, -0.0473277, 1.27276},
                         {5.26645, 3.91568, 4.19121, 4.62005, 5.61328, 1.61731,
                          1.25975, -1.93708, -1.18664, 17.4464},
                         {-2.97335, -3.7912, -3.42211, -2.58479, -1.78914,
                          1.01628, 0.115187, 1.35248, -2.17675, 0.918943},
                         {5.18371, 4.66033, 5.47123, 6.01831, 6.72858, -1.51387,
                          -1.24989, 1.99399, 1.34265, -0.29066},
                         {-8.8543, -9.27424, -8.6469, -8.50893, -7.96376,
                          2.29364, 1.33127, 1.41738, 1.76304, 2.60043}};
  for (const auto& sample : data) {
    double actual = InterpolateCubicHermite(sample[0], sample[1], sample[2],
                                            sample[3], sample[4], sample[5],
                                            sample[6], sample[7], sample[8]);
    EXPECT_NEAR(sample[9], actual, tolerance);
  }
}

TEST(InterpolateCatmullRomTest, Samples) {
  // See accompanying Mathematica notebook test_interpolation.nb for
  // generating test data.
  const double tolerance = 5e-2;
  double data[20][10] = {
      {-5.31089, -5.67611, -5.65562, -4.88323, -4.09323, -1.68468, -0.686788,
       -1.58085, 2.72862, -1.23449},
      {-7.8888, -9.12719, -8.74246, -7.96519, -7.01115, -2.8356, 2.45883,
       2.20888, -0.850792, 2.07626},
      {-8.55186, -9.25271, -8.86908, -8.63841, -8.01475, 2.53283, 0.181233,
       -1.47049, 1.62212, -0.613373},
      {7.16828, 6.13649, 6.57441, 7.31185, 7.55112, -0.258468, -2.25433,
       1.33062, 0.0851792, 0.783314},
      {4.13379, 3.49904, 4.00817, 4.08415, 4.61497, -1.87802, -0.51715,
       -0.0424153, 2.80365, -0.00433204},
      {6.43152, 4.83869, 5.5775, 6.55762, 7.2358, -1.71925, -1.97914, -2.26444,
       -1.39211, -2.28986},
      {-6.50195, -7.26088, -6.60575, -6.43859, -5.57506, -2.8532, 0.7134,
       0.755645, -0.419593, 0.834344},
      {1.44564, 1.4313, 1.47227, 1.74111, 1.93334, 0.454058, -0.775581,
       0.388864, 0.430442, -0.739841},
      {-1.94707, -2.15937, -1.77583, -1.22606, -0.726579, 0.896516, -1.01893,
       -0.619291, 2.72685, -0.649821},
      {0.678023, -0.375201, 0.576664, 0.90994, 1.38501, -0.193135, -1.24382,
       1.52434, 1.49892, -0.638628},
      {0.103041, 0.0429156, 0.673714, 0.771968, 1.01418, -1.84014, 2.17805,
       2.45814, 1.45915, 31.9812},
      {4.56898, 4.0574, 4.23801, 4.30758, 4.87897, 2.39994, 0.741758,
       -0.00399112, -1.81566, 42.203},
      {4.21623, 4.11861, 4.81077, 4.93715, 5.61573, 1.725, -2.33047, 1.24512,
       -2.50675, 994.392},
      {9.12316, 8.93166, 9.17467, 9.96319, 10.4849, 0.761658, -0.624622,
       2.10278, -0.0633029, -0.665725},
      {-8.16379, -8.66288, -8.35392, -7.97298, -7.74336, -1.71383, 1.70275,
       1.52996, 2.19219, 1.80277},
      {-5.49229, -6.10029, -5.81757, -5.58431, -5.1269, -0.983315, 0.33289,
       2.90872, 0.653191, 1.85458},
      {1.17048, 0.917999, 1.45034, 2.41335, 3.11809, -2.95911, -2.80901,
       -0.815399, 2.16751, -3.18753},
      {-0.670635, -2.18967, -1.58743, -0.72445, -0.231485, -0.00946792,
       -1.79626, -0.885342, -1.68263, -0.893452},
      {-2.35355, -3.01714, -2.10127, -1.24756, -0.989421, -1.02209, -0.768114,
       -2.82136, -1.66345, -0.90372},
      {-9.17349, -9.74392, -8.96522, -8.80023, -8.5585, -1.00747, -0.95038,
       2.9009, -0.728431, 28.2161}};
  for (const auto& sample : data) {
    double actual = InterpolateCatmullRom(sample[0], sample[1], sample[2],
                                          sample[3], sample[4], sample[5],
                                          sample[6], sample[7], sample[8]);
    EXPECT_NEAR(sample[9], actual, tolerance);
  }
}

TEST(InterpolateTest, VectorSamples) {
  using Vector3f = Vector3<float>;
  float data[20][10] = {{0.345409, -0.0361089, 1.04817, -1.30041, -4.3553,
                         -0.95586, 1.91822, -1.52799, 0.355963, -0.188666},
                        {0.198124, -2.07645, 1.57368, 0.119065, -1.90333,
                         -0.548457, -3.79047, -2.04215, 1.15324, -0.655506},
                        {0.329535, 0.786172, 0.817311, 1.05537, 0.364373,
                         0.78353, 1.03566, 0.647174, 0.806179, 1.04887},
                        {0.681196, -0.832118, 2.46161, 1.43226, -0.216184,
                         -2.04982, 1.71663, -0.412546, -0.611561, 1.62597},
                        {0.675577, -3.77721, -0.297763, 2.0856, 0.782012,
                         -2.02374, 1.02464, -0.697106, -1.46379, 1.36884},
                        {0.621754, -1.82168, 0.790987, 1.75033, -1.08589,
                         -0.491425, 1.15463, -1.3642, -0.00635839, 1.37995},
                        {0.920586, -1.0664, 0.632208, -2.64105, 1.0219, 1.99893,
                         -0.919439, 0.856058, 1.89039, -1.05616},
                        {0.238644, 0.723635, -0.461489, -0.267019, -4.55716,
                         -0.543381, -3.03285, -0.536596, -0.481032, -0.927067},
                        {0.446999, -0.552363, -0.929821, -2.33836, -0.424627,
                         1.23236, -0.472651, -0.495265, 0.0366735, -1.50439},
                        {0.646645, -0.404723, -2.85749, 0.922452, 0.600025,
                         -4.02791, -2.1522, 0.244993, -3.61434, -1.06575},
                        {0.0415033, -1.62951, -4.32755, 2.01259, -0.186881,
                         -0.349444, -0.284247, -1.56964, -4.16244, 1.91727},
                        {0.586826, 5.60841, -0.227178, -0.717552, 0.318484,
                         -2.9055, -0.5008, 2.50415, -1.79888, -0.590357},
                        {0.979483, 0.540832, 0.133745, 1.19085, 1.42184,
                         -0.231394, -0.933599, 1.40376, -0.223903, -0.890011},
                        {0.417358, 0.63586, -0.339224, -1.77174, 1.75072,
                         -0.70724, 1.16381, 1.10115, -0.492818, -0.546561},
                        {0.574815, 0.77095, -2.65663, 0.853876, -0.672304,
                         -0.229636, -0.478929, -0.058654, -1.26156, 0.0877593},
                        {0.092775, -0.737166, -1.25153, 2.33118, -3.07478,
                         0.0234556, 0.800701, -0.954037, -1.13325, 2.18919},
                        {0.0941846, -0.885316, -2.49301, -0.279896, 2.79821,
                         -1.51028, -0.427784, -0.538385, -2.40045, -0.293825},
                        {0.612455, -0.829811, -0.0463265, -1.65414, -1.70333,
                         -3.47754, 0.937727, -1.3648, -2.14779, -0.0667368},
                        {0.669528, -0.569445, 0.065623, 3.97966, -0.825,
                         -0.99781, -1.08803, -0.740546, -0.646375, 0.586696},
                        {0.929647, 2.37221, -3.3022, 0.855776, 0.610551,
                         -1.53931, 0.607655, 0.734489, -1.66333, 0.625111}};
  for (const auto& sample : data) {
    float p = sample[0];
    Vector3f y0 = Vector3f{sample[1], sample[2], sample[3]};
    Vector3f y1 = Vector3f{sample[4], sample[5], sample[6]};
    Vector3f expected_point{sample[7], sample[8], sample[9]};
    Vector3f actual_point = Interpolate(p, y0, y1);
    EXPECT_THAT(expected_point, IsApprox(actual_point, 1e-5));
  }
}

TEST(InterpolateTest, SO2SymmetricAroundIdentity) {
  EXPECT_THAT(Interpolate(0.5, SO2d{-0.1}, SO2d{0.1}), IsApprox(SO2d{}, 1e-16));
  EXPECT_THAT(Interpolate(0.5, SO2d{0.1}, SO2d{-0.1}), IsApprox(SO2d{}, 1e-16));
  EXPECT_THAT(Interpolate(0.5, SO2d{0.5}, SO2d{0.3}),
              IsApprox(SO2d{0.4}, 1e-16));
}

TEST(InterpolateTest, SO2HalfTurnDifferenceYieldsDeterministicPoint) {
  SO2d expected{0, 1};
  EXPECT_THAT(Interpolate(0.5, SO2d{1, 0}, SO2d{-1, 0}),
              IsApprox(expected, 1e-16));
  EXPECT_THAT(Interpolate(0.5, SO2d{-1, 0}, SO2d{1, 0}),
              IsApprox(expected, 1e-16));
}

TEST(InterpolateTest, SO2Samples) {
  float data[20][7] = {
      {0.276757, 0.833462, 0.552577, 0.54207, 0.840334, 0.7651, 0.643912},
      {0.51062, 0.538323, 0.842738, -0.976995, -0.213264, -0.592078, 0.805881},
      {0.809644, -0.940349, -0.340212, 0.512772, -0.858525, 0.201599,
       -0.979468},
      {0.0809791, -0.45601, 0.889975, -0.866421, 0.499314, -0.496904, 0.867805},
      {0.741935, -0.148724, 0.988879, 0.12333, -0.992366, -0.629162, -0.777275},
      {0.432433, 0.99618, 0.0873197, -0.276057, 0.961141, 0.660108, 0.75117},
      {0.285706, -0.580971, -0.813924, -0.485454, -0.874262, -0.554386,
       -0.83226},
      {0.733475, 0.925003, -0.379961, 0.958986, -0.283455, 0.950897, -0.309508},
      {0.0214717, 0.948758, -0.316005, 0.957914, -0.287056, 0.948963,
       -0.315386},
      {0.0932281, 0.875089, 0.483962, -0.341348, -0.939937, 0.961287, 0.27555},
      {0.310417, 0.97051, 0.241061, -0.887857, 0.46012, 0.544781, 0.838578},
      {0.371038, 0.180686, -0.983541, 0.604257, -0.796789, 0.347603, -0.937642},
      {0.141826, -0.571973, 0.820272, 0.717774, -0.696276, -0.189386, 0.981903},
      {0.543679, 0.999399, -0.0346545, -0.577749, 0.816214, 0.387313, 0.921948},
      {0.602155, -0.975244, 0.221133, 0.46889, -0.883257, -0.407551, -0.913182},
      {0.911657, -0.719361, 0.694637, -0.631651, -0.775253, -0.737859,
       -0.674955},
      {0.577396, -0.599791, 0.800157, -0.959488, -0.281748, -0.974329,
       0.225129},
      {0.106923, 0.50177, 0.865001, -0.179886, 0.983687, 0.435057, 0.900403},
      {0.504614, -0.772675, 0.634802, 0.955537, -0.294872, 0.484892, 0.874574},
      {0.0244658, -0.618183, -0.786034, 0.358924, 0.933367, -0.671305,
       -0.741181}};
  for (const auto& sample : data) {
    float p = sample[0];
    SO2f y0{sample[1], sample[2]};
    SO2f y1{sample[3], sample[4]};
    SO2f expected{sample[5], sample[6]};
    SO2f result = Interpolate(p, y0, y1);
    ASSERT_THAT(result, IsApprox(expected, 1e-5));
  }
}

TEST(InterpolateTest, SO3SymmetricRotationsAroundZ) {
  EXPECT_THAT(
      Interpolate(0.5, Quaterniond{Eigen::AngleAxisd(-0.1, Vector3d{0, 0, 1})},
                  Quaterniond{Eigen::AngleAxisd(+0.1, Vector3d{0, 0, 1})}),
      IsApprox(Quaterniond::Identity(), 1e-16));
}

TEST(InterpolateTest, SO3ReversedQuaternionRepresentation) {
  EXPECT_THAT(
      Interpolate(0.5, Quaterniond{1, 0, 0, 0}, Quaterniond{-1, 0, 0, 0}),
      IsApprox(Quaterniond::Identity(), 1e-16));
}

TEST(InterpolateTest, SO3UnitQuaternions) {
  EXPECT_THAT(
      Interpolate(0.5, Quaterniond{1, 0, 0, 0}, Quaterniond{0, 1, 0, 0}),
      IsApprox(Quaterniond{0.70710678118654746, 0.70710678118654746, 0, 0},
               1e-16));
  EXPECT_THAT(
      Interpolate(0.5, Quaterniond{1, 0, 0, 0}, Quaterniond{0, 0, 1, 0}),
      IsApprox(Quaterniond{0.70710678118654746, 0, 0.70710678118654746, 0},
               1e-16));
  EXPECT_THAT(
      Interpolate(0.5, Quaterniond{1, 0, 0, 0}, Quaterniond{0, 0, 0, 1}),
      IsApprox(Quaterniond{0.70710678118654746, 0, 0, 0.70710678118654746},
               1e-16));
}

TEST(InterpolateTest, SO3Samples) {
  float data[20][13] = {
      {0.0815877, -0.691521, 0.346669, 0.407912, -0.485002, 0.203664, 0.963485,
       -0.165796, 0.0522399, -0.653718, 0.455892, 0.38012, -0.469386},
      {0.111575, -0.535755, 0.640856, -0.546116, 0.0634613, -0.0846383,
       0.927337, 0.248688, 0.266526, -0.506338, 0.715886, -0.47144, 0.0941992},
      {0.992386, 0.821462, 0.341373, 0.327287, 0.318665, 0.424867, -0.688715,
       -0.524718, 0.264253, 0.434369, -0.684438, -0.520669, 0.267901},
      {0.11242, -0.112888, 0.664248, 0.727012, -0.132229, -0.502597, 0.025696,
       0.180602, -0.845055, -0.180627, 0.630467, 0.712527, -0.249381},
      {0.585528, -0.125409, -0.851653, 0.462473, 0.212315, -0.67213, 0.375056,
       -0.182264, 0.611844, 0.425762, -0.745702, 0.389179, -0.333459},
      {0.235627, -0.174953, -0.430152, 0.884158, -0.0512367, 0.994315,
       0.0560037, -0.000478368, 0.0905648, -0.475778, -0.397919, 0.780862,
       -0.0745062},
      {0.449991, 0.467435, 0.659385, -0.273285, -0.521566, -0.495466, 0.354169,
       0.684835, 0.400098, 0.574238, 0.236135, -0.55108, -0.557495},
      {0.813617, 0.0213027, 0.373336, -0.904271, -0.206059, 0.760155, 0.294416,
       -0.310295, 0.489081, 0.687668, 0.355563, -0.499573, 0.388735},
      {0.0433564, -0.565754, -0.110914, -0.789352, 0.211054, 0.168499,
       -0.982469, 0.0310607, 0.073468, -0.552839, -0.177286, -0.785178,
       0.215486},
      {0.220809, 0.95593, -0.033856, 0.148267, -0.251135, -0.946176, 0.111827,
       -0.0295986, 0.302275, 0.955657, -0.0512023, 0.122262, -0.262965},
      {0.0671831, 0.5464, 0.337575, 0.374997, 0.668482, 0.195581, 0.0912133,
       -0.905275, 0.365931, 0.561185, 0.343672, 0.278524, 0.699561},
      {0.0573009, 0.626342, -0.741235, 0.241109, -0.0115363, 0.431015, 0.657614,
       -0.395457, -0.474746, 0.577508, -0.771848, 0.264811, 0.0247045},
      {0.177765, 0.220729, 0.253186, -0.76545, -0.548874, -0.451736, 0.122114,
       -0.760333, 0.450463, 0.093419, 0.25947, -0.877497, -0.392361},
      {0.438044, 0.968325, 0.167712, 0.0340583, 0.181823, 0.335462, -0.640616,
       -0.667056, -0.1792, 0.894546, -0.254616, -0.366444, 0.0260115},
      {0.757331, 0.595184, 0.319291, 0.714821, 0.181217, -0.0659281, -0.786507,
       0.497045, -0.360564, 0.282554, 0.848719, -0.19545, 0.402043},
      {0.90725, 0.0678024, -0.00287804, 0.968742, -0.238608, -0.220727,
       0.673415, -0.183826, -0.681175, 0.227112, -0.663873, 0.318934, 0.637161},
      {0.143253, -0.32056, 0.448862, -0.760723, -0.342147, -0.84445, 0.326422,
       -0.293128, -0.307293, -0.413586, 0.445138, -0.713704, -0.348462},
      {0.878621, 0.503688, 0.477825, -0.71837, -0.0438809, -0.228592, 0.471948,
       -0.577482, 0.625721, -0.136268, 0.503712, -0.635938, 0.568584},
      {0.119913, -0.83756, 0.107493, 0.285896, -0.452992, 0.829802, -0.499875,
       -0.175018, 0.175846, -0.847818, 0.15796, 0.275875, -0.424436},
      {0.217789, 0.637157, -0.485274, -0.595718, -0.0604979, 0.268914, 0.554729,
       0.440352, -0.652726, 0.480152, -0.58036, -0.644438, 0.13167}};
  for (const auto& sample : data) {
    float p = sample[0];
    Quaternionf y0{sample[1], sample[2], sample[3], sample[4]};
    Quaternionf y1{sample[5], sample[6], sample[7], sample[8]};
    Quaternionf expected{sample[9], sample[10], sample[11], sample[12]};
    // normal test
    Quaternionf result = Interpolate(p, y0, y1);
    ASSERT_THAT(SO3f(expected), IsApprox(SO3f(result), 1e-5));
    // additional tests for interpolate(+/-a, +/-b)
    result = Interpolate(p, y0, Quaternionf{-y1.coeffs()});
    ASSERT_THAT(SO3f(expected), IsApprox(SO3f(result), 1e-5));
    result = Interpolate(p, Quaternionf{-y0.coeffs()}, y1);
    ASSERT_THAT(SO3f(expected), IsApprox(SO3f(result), 1e-5));
    result =
        Interpolate(p, Quaternionf{-y0.coeffs()}, Quaternionf{-y1.coeffs()});
    ASSERT_THAT(SO3f(expected), IsApprox(SO3f(result), 1e-5));
  }
}

TEST(InterpolateTest, Pose2Samples) {
  TestGenerator rnd_engine(kGeneratorTestSeed);
  UniformDistributionPose2<float> pose_dist;
  std::uniform_real_distribution<float> dist(0, 1);
  for (int i = 0; i < 20; i++) {
    float p = dist(rnd_engine);
    Pose2f y0 = pose_dist(rnd_engine);
    Pose2f y1 = pose_dist(rnd_engine);
    Pose2f expected_pose(Interpolate(p, y0.translation(), y1.translation()),
                         Interpolate(p, y0.so2(), y1.so2()));
    EXPECT_THAT(Interpolate(p, y0, y1), IsApprox(expected_pose, 1e-5));
  }
}

TEST(InterpolateTest, Pose3Samples) {
  TestGenerator rnd_engine(kGeneratorTestSeed);
  UniformDistributionPose3<float> pose_dist;
  std::uniform_real_distribution<float> dist(0, 1);
  for (int i = 0; i < 20; i++) {
    float p = dist(rnd_engine);
    Pose3f y0 = pose_dist(rnd_engine);
    Pose3f y1 = pose_dist(rnd_engine);
    Pose3f expected_pose(Interpolate(p, y0.quaternion(), y1.quaternion()),
                         Interpolate(p, y0.translation(), y1.translation()));
    EXPECT_THAT(Interpolate(p, y0, y1), IsApprox(expected_pose, 1e-5));
  }
}

}  // namespace
}  // namespace eigenmath
